# Module 9 – Pick & Place Robot


Robot programming defines the sequence of motions, gripper actions, and decision logic for automated operation.

## Programming Methods

**Teach Pendant**
- Handheld controller with jog buttons
- Move robot to desired positions
- Record positions to program memory
- Common on commercial robots
- Intuitive for non-programmers

Advantages:
- No CAD or simulation needed
- Immediate feedback
- Easy to adjust positions

Disadvantages:
- Requires physical robot access
- Time-consuming for complex sequences
- Difficult to duplicate programs

**Text-Based Programming**

G-Code (CNC-style):
```gcode
O1000 (Pick and Place Program)
G0 X100 Y50 Z100         ; Move to safe position
G1 Z10 F500              ; Lower to pick height
M64 P0                   ; Gripper on
G4 P0.5                  ; Dwell 500ms
G0 Z100                  ; Retract
G0 X200 Y150             ; Move to place location
G1 Z15                   ; Lower to place
M65 P0                   ; Gripper off
G0 Z100                  ; Retract
M30                      ; Program end
```

Robot-Specific Language (example):
```
MOVE P1 SPEED=100
GRIP ON
WAIT 0.5
MOVE P2 SPEED=80
GRIP OFF
```

Python/Scripting:
```python
robot.move(x=100, y=50, z=100, speed=1000)
robot.move(z=10, speed=500)
robot.gripper_on()
time.sleep(0.5)
robot.move(z=100)
robot.move(x=200, y=150)
robot.move(z=15, speed=500)
robot.gripper_off()
robot.move(z=100)
```

**Graphical Programming**
- Drag-and-drop blocks (Blockly, LabVIEW)
- Visual flowcharts
- Easier for complex logic
- Good for non-programmers

**Offline Programming**
- Simulate robot in CAD/CAM software
- Generate programs without robot access
- Verify collisions and reach
- Examples: RoboDK, ABB RobotStudio, KUKA Sim

## Program Structure

**Main Sequence**
```
INIT:
  - Home robot
  - Initialize gripper
  - Reset counters

LOOP:
  - Call vision routine
  - Calculate pick position
  - Execute pick sequence
  - Execute place sequence
  - Increment counter
  - Check for errors
  - Repeat

ERROR_HANDLER:
  - Stop motion
  - Release gripper
  - Move to safe position
  - Signal fault
```

**Subroutines**
Modular programming improves maintainability:

```gcode
O1000 (Main program)
M98 P1001 (Call pick routine)
M98 P1002 (Call place routine)
M30

O1001 (Pick routine)
G0 X#100 Y#101 Z50
G1 Z#102 F500
M64 P0
G4 P0.5
G0 Z50
M99

O1002 (Place routine)
G0 X#103 Y#104 Z50
G1 Z#105
M65 P0
G0 Z50
M99
```

## Position Management

**Absolute Positioning**
- Coordinates specified relative to machine origin
- Consistent, repeatable
- Programs not portable between robots

**Relative Positioning**
- Offsets from current position
- Useful for incremental moves
- Accumulates errors if not managed

**Named Positions**
Define positions as variables:
```python
PICK_APPROACH = (100, 50, 100)
PICK_POSITION = (100, 50, 10)
PLACE_APPROACH = (200, 150, 100)
PLACE_POSITION = (200, 150, 15)
```

**Position Arrays**
Handle multiple locations:
```python
pick_positions = [
    (100, 50, 10),
    (120, 50, 10),
    (140, 50, 10),
]

for pos in pick_positions:
    robot.move(*pos)
    robot.pick()
```

## Vision-Guided Programming

**Vision Offset Correction**
1. Move to nominal pick position
2. Trigger camera capture
3. Vision system calculates offset (ΔX, ΔY, Δθ)
4. Adjust pick position by offset
5. Execute pick

```python
def vision_pick(nominal_x, nominal_y, z):
    # Move to vision position
    robot.move(nominal_x, nominal_y, z + 50)

    # Get vision offset
    offset = vision_system.get_offset()

    # Apply offset
    actual_x = nominal_x + offset.x
    actual_y = nominal_y + offset.y
    actual_rotation = offset.rotation

    # Adjust gripper rotation if available
    robot.set_rotation(actual_rotation)

    # Execute pick
    robot.move(actual_x, actual_y, z)
    robot.gripper_on()
    robot.move(z=z+50)
```

**Dynamic Part Tracking**
For moving conveyors:
```python
def conveyor_pick():
    # Wait for part detection
    while not conveyor_sensor.part_detected():
        time.sleep(0.01)

    # Get current part position
    part_pos = conveyor.get_part_position()

    # Calculate intercept point
    intercept = calculate_intercept(part_pos, conveyor_speed, robot_speed)

    # Track and pick
    robot.track_conveyor(intercept, conveyor_speed)
    robot.gripper_on()
    robot.stop_tracking()
```

## Error Handling and Recovery

**Common Errors**
- Gripper failed to grip (no vacuum, jaws blocked)
- Part not found by vision
- Motion limit exceeded
- Communication timeout
- Safety stop triggered

**Error Detection**
```python
def safe_pick(x, y, z):
    robot.move(x, y, z)
    robot.gripper_on()
    time.sleep(0.3)

    # Check if part gripped
    if not gripper.has_part():
        # No part detected
        robot.gripper_off()
        robot.move(z=z+50)
        raise PickError("Failed to grip part")

    # Success
    robot.move(z=z+50)
```

**Recovery Strategies**

Retry:
```python
max_retries = 3
for attempt in range(max_retries):
    try:
        safe_pick(x, y, z)
        break  # Success
    except PickError:
        if attempt == max_retries - 1:
            signal_fault()
            stop_system()
```

Skip and Continue:
```python
try:
    safe_pick(x, y, z)
except PickError:
    log_error("Missed pick at position X{} Y{}".format(x, y))
    increment_miss_counter()
    continue  # Move to next part
```

Operator Intervention:
```python
except PickError:
    pause_system()
    display_message("Pick failed. Please check and press continue.")
    wait_for_operator_confirmation()
    resume_system()
```

## Advanced Programming Techniques

**Array Processing**
Pick from grid of parts:
```python
for row in range(num_rows):
    for col in range(num_cols):
        x = start_x + col * spacing_x
        y = start_y + row * spacing_y
        pick_and_place(x, y, pick_z, place_x, place_y, place_z)
```

**Palletizing**
Stack parts in layers:
```python
def palletize(part_num):
    layer = part_num // parts_per_layer
    position_in_layer = part_num % parts_per_layer

    row = position_in_layer // parts_per_row
    col = position_in_layer % parts_per_row

    x = pallet_x + col * part_spacing_x
    y = pallet_y + row * part_spacing_y
    z = pallet_z + layer * part_height

    robot.place(x, y, z)
```

**Conditional Logic**
```python
if part_weight > 2.0:
    use_large_gripper()
else:
    use_small_gripper()

if vision.part_type == "TYPE_A":
    place_position = bin_a
elif vision.part_type == "TYPE_B":
    place_position = bin_b
else:
    place_position = reject_bin
```

**State Machines**
Manage complex sequences:
```python
state = "IDLE"

while True:
    if state == "IDLE":
        if part_available():
            state = "PICK_APPROACH"

    elif state == "PICK_APPROACH":
        move_to_pick_approach()
        state = "PICK"

    elif state == "PICK":
        execute_pick()
        if gripper.has_part():
            state = "PLACE_APPROACH"
        else:
            state = "ERROR"

    # ... additional states
```

## Simulation and Testing

**Offline Simulation**
- Test programs before running on real robot
- Verify reach and avoid collisions
- Optimize cycle times
- Train operators

**Dry Run Mode**
- Execute program at slow speed
- No gripper activation
- Verify motion paths
- Check clearances

**Single-Step Mode**
- Execute one command at a time
- Verify each position
- Debug logic
- Safe for initial testing

## Program Optimization

**Reduce Cycle Time**
- Minimize Z-axis travel
- Use blended moves (round corners)
- Overlap gripper actuation with motion
- Optimize acceleration profiles

**Reduce Code Complexity**
- Use subroutines for repeated sequences
- Parameterize positions (variables vs. hard-coded)
- Comment code clearly
- Version control for programs

**Example: Before Optimization**
```gcode
G0 X100 Y50 Z100
G0 Z10
M64 P0
G4 P0.5
G0 Z100
G0 X200 Y150
G0 Z15
M65 P0
G0 Z100
```

**After Optimization**
```gcode
G0 X100 Y50 Z100
G1 Z10 F1000
M64 P0                   ; Start gripper activation
G0 Z50                   ; Raise while gripper activates
G4 P0.2                  ; Brief dwell (reduced)
G0 X200 Y150 Z50         ; Move to place approach
G1 Z15 F1000
M65 P0                   ; Release gripper
G0 Z50 (not Z100)        ; Lower clearance height
```
Cycle time reduced by ~30%.

## Documentation

**Program Header**
```gcode
(Program: PICK_PLACE_PCB_V2)
(Date: 2025-11-04)
(Author: Engineer Name)
(Description: Pick PCBs from tray, place in fixture)
(Pick location: Tray at X0 Y0)
(Place location: Fixture at X300 Y200)
(Gripper: Vacuum, 2x 15mm cups)
```

**Inline Comments**
```python
# Calculate pick position from tray index
x = tray_origin_x + (part_index % tray_cols) * part_spacing
y = tray_origin_y + (part_index // tray_cols) * part_spacing

# Vision offset correction applied here
offset = vision.get_offset()
x += offset.x
y += offset.y
```

***

**Next**: [9.8 Safety Systems](section-9.8-safety-systems.md)

---

## References

1. **Robot Programming Languages**
   - ABB RAPID Programming Manual
   - FANUC Karel and TP Programming Reference
   - KUKA Robot Language (KRL) Manual
   - Universal Robots URScript Manual

2. **Software Development**
   - ROS (Robot Operating System) Documentation - ros.org
   - MoveIt Motion Planning Framework - moveit.ros.org
   - Python Robotics Toolbox

3. **Path Planning**
   - LaValle, S.M. (2006). *Planning Algorithms*. Cambridge University Press
   - Latombe, J.C. (1991). *Robot Motion Planning*. Kluwer Academic

4. **Error Handling**
   - IEC 61508 - Functional Safety of Electrical Systems
   - Software exception handling best practices
